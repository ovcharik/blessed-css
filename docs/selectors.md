# 1. Селекторы


## 1.1. Типы селекторов

### 1.1.1. Селекторы по ID (`#id-name`)

Cелекторы по ID производят выборку всех элементов по ID атрибуту, полностью совпадающих с селектором.

Селектор `#id-name` соответствует `<element id="id-name" />`.

### 1.1.2. Селекторы по классу (`.class-name`)

Cелекторы по классу находят элементы с нужным классом. Атрибут класса определяется как разделенный пробелами список, и один из элементов списка должен точно соответствовать имени класса, приведенном в селекторе.

Селектор `.class-name` соответствует `<element class="class-name for bar" />`.

### 1.1.3. Селекторы по имени узла (`element-name`)

Селекторы по имени узла выбирают все элементы с данным именем.

Селектор `element-name` соответствует `<element-name />`.

## 1.1.4. Псевдоклассы (`:pseudo-class`)

Псевдокласс - это ключевое слово, добавленное к селектору, которое определяет его особое состояние.

### 1.1.4.1. Состояние

* `:focus` - применяется, когда элемент получает фокус, либо при выборе его пользователем при помощи клавиатуры, либо активацией его мышью (например, при вводе формы)
* `:hover` - срабатывает, когда пользователь наводит на элемент мышью, но не обязательно активирует его

### 1.1.4.2. Положение

* `:first-child` - находит любой элемент, являющийся первым в своём родителе
* `:last-child` - находит любой элемент, являющийся последним в его родителе
* `:first-of-type` - находит первого потомка своего типа среди детей родителя
* `:last-of-type` - находит последнего потомка с заданным тегом в списке детей родительского элемента

Следующие псевдоклассы могут принимать аргументы в качестве выражения `an + b`, где `n ∈ [0, ∞)`. Примеры:

* выражение `1n+0` или просто `n`, выберет каждый элемент
* `0n+1` - выберет первый элемент (например как `:first-child`)
* `2n+0` - выберет элементы на четных позициях, выражения можно заменить на ключевое слово `even`
* `2n+1` - выберет элементы на нечетных позициях, выражения можно заменить на ключевое слово `odd`
* `3n+4` - выберет элементы на позициях 4, 7, 10, 13, ...

Значение `a` и `b` должны быть целыми числами, а индекс первого элемента равен `1`. Другими словами, это выражение используется для поиска всех детей, чей индекс попадает в `{ an + b; n ∈ [0, ∞) }`

Функции отличаются способом индексации элементов:

* `:nth-child(<expression>)` - индексация сквозная, через всех потомков
* `:nth-last-child(<expression>)` - индексация сквозная, через всех потомков, в обратном направлении
* `:nth-of-type(<expression>)` - индексация только по элементам с заданным селектором
* `:nth-last-of-type(<expression>)` - индексация только по элементам с заданным селектором, в обратном направлении

### 1.1.4.3. Разное

* `:not(<selector>)` - функция, принимает простой селектор в качестве аргумента и находит элементы, не соответствующие указанному селектору (логически можно записать как объединение селекторов по правилу `a && !b`). Аргумент не может содержать других отрицательных селекторов.



## 1.2. Объединение селекторов

Селекторы записанные вместе, без разделителей, выбирают элемент, обладающий всеми указанными селекторами одновременно. Если нужно объединить селекторы разных типов, то сперва записывается селектор по имени узла, далее селектор по ID и далее селекторы по классам, классов может быть несколько.

Селектор `block#root.foo.bar`, будет соответсвовать `<block id="root" class="foo bar baz"/>`, и не будет `<block id="root" class="foo baz"/>`.



## 1.3. Комбинаторы

Позволяют задать свойства к элементам, используя комбинацию селекторов. Можно установить отношения, такие как следование (для потомков одного родителя) и наследование (родитель - потомок). Последний селектор в комбинации, будет выбирать элемент, если выполнены все условия комбинации.

### 1.3.1. Селектор следующего элемента (`~`)

Комбинатор `~` разделяет два селектора, и находит второй элемент, если ему предшествует первый, и они имеют общего родителя.

Пример: `.foo ~ .bar`

```html
<block class="bar" /><!-- не выберет -->
<block class="foo" />
<block class="bar" /><!-- выберет -->
<block class="bar" /><!-- выберет -->
```

### 1.3.4. Селектор смежного элемента (`+`)

Комбинатор `+` указывает на смежный или следующий селектор. Обеспечивает выбор только элемента расположенного непосредственно за определенным в первой части элементом.

Пример: `.foo + .bar`

```html
<block class="bar" /><!-- не выберет -->
<block class="foo" />
<block class="bar" /><!-- выберет -->
<block class="bar" /><!-- не выберет -->
```

### 1.3.3. Селектор дочерних элементов (` ` - пробел)

Комбинатор ` ` (пробел) представляет собой 2 или более селекторов, найдет элементы соответвующие обоим селекторам, без учета вложенности элементов.

Пример: `root .foo .bar`

```html
<root>
  <line class="bar" /><!-- не выберет -->

  <block class="foo">
    <line class="bar" /><!-- выберет -->

    <block>
      <line class="bar" /><!-- выберет -->
    </block>
  </block>
</root>
```

### 1.3.4. Селектор потомков (`>`)

Комбинатор `>` разделяет 2 селектора, находит элементы заданные вторым селектором, являющие прямыми потомками для элементов отобранных первым селектором.

Пример: `root > .bar`

```html
<root>
  <line class="bar" /><!-- выберет -->

  <block class="foo">
    <line class="bar" /><!-- не выберет -->
  </block>
</root>
```


## 1.4. Вес селектора

Каждый селектор и свойство обладает весом. Вес разделяется по маске:

* `0001` - селектор по имени узла
* `0010` - селектор по классам и псевдоклассам
* `0100` - селектор по id
* `1000` - атрибут `style`

При объединении и комбинации селекторов вес складывается. Алгоритм расчета:

```
// Селектор
screen#root .section .content > .header line.bold

// Изначальный вес
[0, 0, 0, 0]

// Идентификаторы
#main     [0, 1, 0, 0]

// Классы
.section  [0, 1, 1, 0]
.content  [0, 1, 2, 0]
.header   [0, 1, 3, 0]
.bold     [0, 1, 4, 0]

// Узлы
screen    [0, 1, 4, 1]
line      [0, 1, 4, 2]

// Итог
screen#root .section .content > .header line.bold
=>
[0, 1, 4, 2]
```

Чем больше вес селектора, тем выше приоритет у свойств, описанных в нем. Чтобы задать свойству наивысший приоритет, можно использовать ключ `!important`. Если вес селекторов одинаковый, то приоритет будет у свойств селектора, который был описан последним.
